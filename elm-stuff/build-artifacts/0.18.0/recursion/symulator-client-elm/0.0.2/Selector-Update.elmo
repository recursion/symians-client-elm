var _recursion$symulator_client_elm$Selector_Update$add = F2(
	function (coords, model) {
		return _elm_lang$core$Native_Utils.update(
			model,
			{
				selected: A2(
					_elm_lang$core$Basics_ops['++'],
					model.selected,
					{
						ctor: '::',
						_0: coords,
						_1: {ctor: '[]'}
					})
			});
	});
var _recursion$symulator_client_elm$Selector_Update$remove = F2(
	function (coords, model) {
		var notCoords = function (n) {
			return !_elm_lang$core$Native_Utils.eq(n, coords);
		};
		var nextSelected = A2(_elm_lang$core$List$filter, notCoords, model.selected);
		return _elm_lang$core$Native_Utils.update(
			model,
			{selected: nextSelected});
	});
var _recursion$symulator_client_elm$Selector_Update$createSelection = F2(
	function (coords, model) {
		var wrapCoords = F2(
			function (x, y) {
				return A3(_recursion$symulator_client_elm$World_Models$Coordinates, x, y, coords.z);
			});
		var start = function () {
			var _p0 = model.start;
			if (_p0.ctor === 'Nothing') {
				return coords;
			} else {
				return _p0._0;
			}
		}();
		var width = (_elm_lang$core$Native_Utils.cmp(start.x, coords.x) > 0) ? (start.x - coords.x) : (coords.x - start.x);
		var height = (_elm_lang$core$Native_Utils.cmp(start.y, coords.y) > 0) ? (start.y - coords.y) : (coords.y - start.y);
		var generateCoords = function (x) {
			var range = (_elm_lang$core$Native_Utils.cmp(start.y, coords.y) > 0) ? A2(_elm_lang$core$List$range, start.y - height, start.y) : A2(_elm_lang$core$List$range, start.y, start.y + height);
			return A2(
				_elm_lang$core$List$map,
				wrapCoords(x),
				range);
		};
		var range = (_elm_lang$core$Native_Utils.cmp(start.x, coords.x) > 0) ? A2(_elm_lang$core$List$range, start.x - width, start.x) : A2(_elm_lang$core$List$range, start.x, width + start.x);
		return A2(_elm_lang$core$List$concatMap, generateCoords, range);
	});
var _recursion$symulator_client_elm$Selector_Update$updateSelection = F2(
	function (coords, model) {
		var _p1 = model.mode;
		switch (_p1.ctor) {
			case 'Designate':
				return A2(_recursion$symulator_client_elm$Selector_Update$add, coords, model);
			case 'Undesignate':
				return A2(_recursion$symulator_client_elm$Selector_Update$remove, coords, model);
			default:
				var selected = A2(_recursion$symulator_client_elm$Selector_Update$createSelection, coords, model);
				var _p2 = model.selected;
				if (_p2.ctor === '[]') {
					return _elm_lang$core$Native_Utils.update(
						model,
						{
							start: _elm_lang$core$Maybe$Just(coords),
							buffer: selected
						});
				} else {
					return _elm_lang$core$Native_Utils.update(
						model,
						{buffer: selected});
				}
		}
	});
var _recursion$symulator_client_elm$Selector_Update$update = F2(
	function (msg, model) {
		var _p3 = msg;
		switch (_p3.ctor) {
			case 'Select':
				var _p4 = _p3._0;
				return A2(
					_recursion$symulator_client_elm$Selector_Update$updateSelection,
					_p4,
					_elm_lang$core$Native_Utils.update(
						model,
						{
							start: _elm_lang$core$Maybe$Just(_p4)
						}));
			case 'MouseOver':
				return model.enabled ? A2(_recursion$symulator_client_elm$Selector_Update$updateSelection, _p3._0, model) : model;
			case 'ChangeMode':
				return _elm_lang$core$Native_Utils.update(
					model,
					{mode: _p3._0, start: _elm_lang$core$Maybe$Nothing});
			case 'Enable':
				return _elm_lang$core$Native_Utils.update(
					model,
					{enabled: true});
			default:
				return _elm_lang$core$Native_Utils.update(
					model,
					{
						enabled: false,
						selected: A2(_elm_lang$core$Basics_ops['++'], model.buffer, model.selected),
						buffer: {ctor: '[]'}
					});
		}
	});
